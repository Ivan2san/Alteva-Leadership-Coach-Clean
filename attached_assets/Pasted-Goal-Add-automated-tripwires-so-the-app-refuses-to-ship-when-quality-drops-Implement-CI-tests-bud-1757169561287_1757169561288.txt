Goal
Add automated tripwires so the app refuses to ship when quality drops. Implement CI, tests, budgets, and monitoring for a mobile-first PWA.

Non-negotiables

All checks run on every PR and block merge.

Upload Playwright traces and Lighthouse reports as artifacts.

Only green pipelines reach production.

1) Dev dependencies (add if missing)
npm i -D vitest @testing-library/react @testing-library/user-event jsdom \
@types/jest @types/node \
@axe-core/playwright @playwright/test \
msw \
@lhci/cli \
husky lint-staged \
typescript eslint

2) package.json scripts
{
  "scripts": {
    "typecheck": "tsc -p tsconfig.json --noEmit",
    "lint": "eslint .",
    "test:unit": "vitest run",
    "test:watch": "vitest",
    "e2e": "playwright test",
    "preview": "vite preview --port 4173"
  },
  "lint-staged": {
    "*.{ts,tsx,js,jsx}": ["eslint --fix", "vitest related --run --coverage=false", "git add"]
  }
}

3) Husky pre-commit hook
npx husky install
npx husky add .husky/pre-commit "npx lint-staged"

4) Playwright config (create playwright.config.ts)
import { defineConfig, devices } from "@playwright/test";
export default defineConfig({
  testDir: "./tests",
  timeout: 60_000,
  use: { baseURL: process.env.E2E_BASE_URL || "http://localhost:4173", trace: "on-first-retry" },
  projects: [
    { name: "chromium", use: { ...devices["Pixel 7"] } },
    { name: "webkit",   use: { ...devices["iPhone 14"] } },
    { name: "firefox",  use: { ...devices["Desktop Firefox"] } }
  ],
  reporter: [["list"], ["html", { outputFolder: "playwright-report" }]]
});

5) PWA & a11y tripwire tests

Create tests/pwa.spec.ts:

import { test, expect } from "@playwright/test";

test("service worker registers and offline works", async ({ page, context }) => {
  await page.goto("/");
  const swCount = await page.evaluate(async () =>
    (await navigator.serviceWorker?.getRegistrations())?.length || 0
  );
  expect(swCount).toBeGreaterThan(0);

  // Prime cache
  await page.goto("/growth-profile");

  // Go offline, page must still render core content
  await context.setOffline(true);
  await page.reload();
  await expect(page.getByText(/Growth Profile/i)).toBeVisible();
  await context.setOffline(false);
});

test("manifest present and app installable preconditions", async ({ page }) => {
  await page.goto("/");
  const hasManifest = await page.$('link[rel="manifest"]');
  expect(hasManifest).not.toBeNull();
  const isHttps = await page.evaluate(() => location.protocol === "https:");
  // In CI preview it may be http; allow either, but production must be https (budget in LHCI).
  expect(isHttps || process.env.CI === "true").toBeTruthy();
});


Create tests/a11y.spec.ts:

import { test, expect } from "@playwright/test";
import AxeBuilder from "@axe-core/playwright";

test("home has no critical a11y violations", async ({ page }) => {
  await page.goto("/");
  const results = await new AxeBuilder({ page }).analyze();
  const critical = results.violations.filter(v => ["serious","critical"].includes(v.impact || ""));
  expect(critical).toEqual([]);
});


Create a core-flow smoke tests/flow.spec.ts:

import { test, expect } from "@playwright/test";
test("selects a tile and proceeds", async ({ page }) => {
  await page.goto("/");
  await page.getByRole("button", { name: /Growth Profile/i }).click();
  await page.getByRole("button", { name: /Continue/i }).click();
  await expect(page).toHaveURL(/growth-profile|profile/);
});

6) MSW for stable tests (optional but recommended)

src/mocks/browser.ts:

import { setupWorker } from "msw";
import { handlers } from "./handlers";
export const worker = setupWorker(...handlers);


src/mocks/handlers.ts:

import { http, HttpResponse } from "msw";
export const handlers = [
  http.get("/api/profile", () => HttpResponse.json({ name: "Test User" }))
];


Enable in dev/test only:

if (import.meta.env.DEV) {
  const { worker } = await import("./mocks/browser");
  worker.start({ onUnhandledRequest: "bypass" });
}

7) Lighthouse CI budgets (lighthouserc.json)
{
  "ci": {
    "collect": { "numberOfRuns": 1 },
    "assert": {
      "preset": "lighthouse:recommended",
      "assertions": {
        "categories:performance": ["error", { "minScore": 0.9 }],
        "largest-contentful-paint": ["error", { "maxNumericValue": 2500 }],
        "cumulative-layout-shift": ["error", { "maxNumericValue": 0.1 }],
        "total-byte-weight": ["error", { "maxNumericValue": 500000 }],
        "uses-http2": "warn"
      }
    }
  }
}

8) GitHub Actions CI (.github/workflows/ci.yml)
name: CI
on:
  pull_request:
  push: { branches: [main] }

jobs:
  test_build_e2e:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: 'npm' }
      - run: npm ci
      - run: npm run lint && npm run typecheck
      - run: npm run test:unit -- --reporter=dot
      - run: npm run build
      - run: npx playwright install --with-deps
      - name: Start preview
        run: npm run preview & npx wait-on http://localhost:4173
      - name: E2E (Playwright)
        run: npx playwright test --reporter=line
      - name: Lighthouse CI
        run: lhci autorun --collect.url=http://localhost:4173 --upload.target=filesystem
      - uses: actions/upload-artifact@v4
        if: always()
        with: { name: reports, path: "./playwright-report/** ./ .lighthouseci/**" }

9) Post-deploy synthetic smoke (optional second workflow)
# .github/workflows/smoke.yml
name: Prod Smoke
on:
  schedule: [{ cron: "*/10 * * * *" }]
  workflow_dispatch:

jobs:
  smoke:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20 }
      - run: npm ci
      - run: npx playwright install --with-deps
      - run: E2E_BASE_URL="${{ secrets.PRODUCTION_URL }}" npx playwright test tests/flow.spec.ts --reporter=line

10) Web-vitals + error tripwires in prod

Add Web Vitals reporting:

// src/vitals.ts
import { onLCP, onCLS, onINP } from "web-vitals";
const post = (name: string, value: number) =>
  navigator.sendBeacon?.("/vitals", JSON.stringify({ name, value })) ??
  fetch("/vitals", { method: "POST", keepalive: true, body: JSON.stringify({ name, value }) });

onLCP(v => post("LCP", v.value));
onCLS(v => post("CLS", v.value));
onINP(v => post("INP", v.value));


Wire it in main.tsx:

if (import.meta.env.PROD) import("./vitals");


Error tracking (placeholder, if you use Sentry):

// init once at app start
Sentry.init({ dsn: import.meta.env.VITE_SENTRY_DSN, tracesSampleRate: 0.1 });

11) Branch protection (manual, but required)

Require checks: CI / test_build_e2e and Prod Smoke to pass before merge.

Block direct pushes to main. Require PR + review.

12) Acceptance criteria (gates must fail on breach)

Unit + component tests green.

Playwright E2E passes on Chromium/WebKit/Firefox device profiles.

pwa.spec.ts confirms service worker, manifest and offline rendering.

Lighthouse budgets: perf ≥ 0.9; LCP ≤ 2.5s; CLS ≤ 0.1; total bytes ≤ 500 KB.

Axe critical/serious violations = 0 on /.

Artifacts uploaded for Playwright and Lighthouse.

Prod smoke passes every run; alarms on failures.

End of spec. Implement exactly as written.

Next 3 actions

Paste the spec into Replit, run it, and commit “ci: add tripwires for PWA.”

Turn on branch protection with required checks; set PRODUCTION_URL and VITE_SENTRY_DSN secrets if using smoke + Sentry.

Add one more Playwright test for your most valuable flow to catch real-world breakage early.

Risks & mitigations

Flaky E2E from network jitter. Use MSW where appropriate, explicit expect waits, and keep traces on.

Perf creep from new libraries. Enforce Lighthouse budgets and watch bundle size in PRs.

Service worker cache bugs. Version your SW, show an “Update available” toast, and add an E2E that triggers an update and verifies reload.