The tidy way (keep mocks, pass through chat)
1) Make chat mock opt-in

client/src/mocks/handlers.ts

import { http, HttpResponse } from "msw";

// Mock chat only when explicitly enabled (default: real API)
const MOCK_CHAT = import.meta.env.VITE_MOCK_CHAT === "true";

export const handlers = [
  http.get("/api/profile", () => HttpResponse.json({ name: "Test User" })),

  // Chat: passthrough unless MOCK_CHAT=true, or header asks to bypass
  ...(MOCK_CHAT ? [
    http.post("/api/chat", async ({ request }) => {
      const bypass = request.headers.get("x-msw-bypass") === "true";
      if (bypass) return HttpResponse.passthrough();
      return HttpResponse.json({ message: "This is a test response from the coaching AI." });
    })
  ] : []),

  http.get("/api/conversations", () => HttpResponse.json([])),
  http.get("/api/auth/me", () => HttpResponse.json({ user: null }))
];

2) Don’t disable MSW globally; just load it sanely

client/src/main.tsx

if (import.meta.env.DEV && import.meta.env.VITE_DISABLE_MSW !== "true") {
  const { worker } = await import("./mocks/browser");
  const swUrl = `${import.meta.env.BASE_URL || "/"}mockServiceWorker.js`;
  await worker.start({
    onUnhandledRequest: "bypass",
    serviceWorker: { url: swUrl }
  });
}

3) Call the real server for chat

Where you send chat:

await fetch("/api/chat", {
  method: "POST",
  headers: { "Content-Type": "application/json", "x-msw-bypass": "true" },
  body: JSON.stringify({ input })
});


That header makes the mock step aside even if someone flips VITE_MOCK_CHAT=true.

4) Env toggles you control

Default dev: real chat, mocks for everything else
.env.local

VITE_MOCK_CHAT=false
VITE_DISABLE_MSW=false


Forced mock chat (for demos or offline): set VITE_MOCK_CHAT=true.

Sanity checks so you know it’s working

DevTools → Network: hit /api/chat and confirm the Response tab isn’t the mock JSON.

Console: you should no longer see [MSW] POST /api/chat (200 OK) unless VITE_MOCK_CHAT=true.

If it still mocks, Application → Service Workers → Unregister, hard-reload.

Why this fits the original advice

We wanted MSW to keep tests deterministic. That stays.

We said not to bulldoze MSW just to see real AI. You aren’t; you’re selectively bypassing one route.

CI/E2E can still run with mocks; your manual dev hits the real backend. Everybody wins, even your future self.

Next 3 actions

Apply the snippets above; add VITE_MOCK_CHAT=false locally.

Hard-reload, verify Network shows your server’s /api/chat 200 and not the MSW handler.

Keep the mock chat handler in the repo for tests/demos; toggle with the env var, not code edits.

Risks & mitigations

Leaking API keys by calling OpenAI from the client. Don’t. Always post to your server /api/chat; the server calls the Responses API.

Stale worker caching the old handlers. Unregister + hard-reload whenever you change MSW wiring.

Team confusion flipping toggles. Document VITE_MOCK_CHAT and VITE_DISABLE_MSW in README; add a console log at startup showing their values.