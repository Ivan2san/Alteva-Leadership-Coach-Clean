// server/seed-admin.ts
import { sql } from "drizzle-orm";                 // static: bundlers won't drop this
import { conversations } from "@shared/schema";    // static: same reason
import { storage } from "./storage";

// Prefer env for security; fallback only for local dev
const ADMIN_USER = {
  email: process.env.ADMIN_SEED_EMAIL ?? "admin@leadership-coach.app",
  password: process.env.ADMIN_SEED_PASSWORD ?? "PLEASE-SET-ADMIN_SEED_PASSWORD",
  fullName: "Admin User",
  role: "admin" as const,
};

// Narrow error helper so TS stops complaining
function codeOf(e: unknown): string | undefined {
  return (e && typeof e === "object" && "code" in e) ? String((e as any).code) : undefined;
}
function messageOf(e: unknown): string {
  return (e instanceof Error) ? e.message : String(e);
}

// Best-effort schema readiness probe that works across PG & SQLite
async function schemaReadyProbe(): Promise<boolean> {
  try {
    // Any harmless query that touches the users table/columns your storage relies on
    await storage.getUserByEmail("test@example.com");
    return true;
  } catch (e) {
    const code = codeOf(e);
    const msg = messageOf(e);
    // PG: undefined column/table, SQLite: no such column/table
    const looksLikeMissingSchema =
      code === "42703" || code === "42P01" ||
      msg.includes("no such column") || msg.includes("no such table");
    if (looksLikeMissingSchema) return false;
    // Other errors mean DB exists but different problem; bubble up
    throw e;
  }
}

export async function seedAdminUser() {
  // Skip if schema isn’t migrated yet
  const ready = await schemaReadyProbe().catch((e) => {
    console.error("Schema probe failed (not just unmigrated):", e);
    return false;
  });
  if (!ready) {
    console.log("Database schema not migrated yet. Skipping admin seeding.");
    return null;
  }

  try {
    // Idempotent: return existing if present
    const existing = await storage.getUserByEmail(ADMIN_USER.email);
    if (existing) {
      console.log("Admin user already exists:", ADMIN_USER.email);
      return existing;
    }

    if ((ADMIN_USER.password ?? "").length < 12 || ADMIN_USER.password.includes("PLEASE-SET")) {
      console.warn("Weak or default admin seed password. Set ADMIN_SEED_PASSWORD in env for production.");
    }

    console.log("Creating admin user…");
    const created = await storage.createUser(ADMIN_USER);
    console.log("Admin user created:", ADMIN_USER.email);
    return created;
  } catch (e) {
    const code = codeOf(e);
    if (code === "23505" || code === "SQLITE_CONSTRAINT_UNIQUE") {
      console.log("Admin already exists (unique constraint). Fetching…");
      try {
        return await storage.getUserByEmail(ADMIN_USER.email);
      } catch (fetchErr) {
        console.error("Failed to fetch existing admin after duplicate:", fetchErr);
        return null;
      }
    }
    console.error("Error seeding admin user:", e);
    return null; // don’t kill boot in prod
  }
}

export async function migrateExistingData(adminUserId: string) {
  try {
    console.log("Migrating existing data to admin user…");
    const { db } = await import("./db"); // keep lazy to avoid boot order issues

    // Count orphaned conversations using raw SQL predicate (no isNull import)
    const orphanRows = await db
      .select()
      .from(conversations)
      .where(sql`${conversations.userId} IS NULL`);

    if (orphanRows.length > 0) {
      await db
        .update(conversations)
        .set({ userId: adminUserId })
        .where(sql`${conversations.userId} IS NULL`);

      console.log(`Migrated ${orphanRows.length} conversations to admin user`);
    } else {
      console.log("No orphaned conversations found.");
    }

    console.log("Data migration completed.");
  } catch (e) {
    console.error("Error migrating existing data:", e);
    // swallow during boot
  }
}

// Optional CLI entrypoint: `pnpm seed:admin` will run seed + migrate once
if (process.argv.includes("run")) {
  (async () => {
    const admin = await seedAdminUser();
    if (admin?.id) {
      await migrateExistingData(admin.id);
    }
    // exit cleanly for one-off runs
    if (!process.env.REPL_ID) process.exit(0);
  })().catch((e) => {
    console.error("Seeder failed:", e);
    if (!process.env.REPL_ID) process.exit(1);
  });
}
